<!DOCTYPE html><html lang="en-gb"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Software Rasterizer: Drawing a Triangle - alielmorsy</title><meta name="description" content="The world of 2D graphics is built on triangles as the main primitives for drawing. In fact, even lines and complex polygons are often broken&hellip;"><meta name="generator" content="Publii Open-Source CMS for Static Site"><link rel="canonical" href="https://alielmorsy.github.io/software-rasterizer-drawing-a-triangle/"><link rel="alternate" type="application/atom+xml" href="https://alielmorsy.github.io/feed.xml" title="alielmorsy - RSS"><link rel="alternate" type="application/json" href="https://alielmorsy.github.io/feed.json" title="alielmorsy - JSON"><meta property="og:title" content="Software Rasterizer: Drawing a Triangle"><meta property="og:site_name" content="alielmorsy"><meta property="og:description" content="The world of 2D graphics is built on triangles as the main primitives for drawing. In fact, even lines and complex polygons are often broken&hellip;"><meta property="og:url" content="https://alielmorsy.github.io/software-rasterizer-drawing-a-triangle/"><meta property="og:type" content="article"><link rel="preload" href="https://alielmorsy.github.io/assets/dynamic/fonts/jetbrainsmono/jetbrainsmono.woff2" as="font" type="font/woff2" crossorigin><link rel="preload" href="https://alielmorsy.github.io/assets/dynamic/fonts/jetbrainsmono/jetbrainsmono-italic.woff2" as="font" type="font/woff2" crossorigin><link rel="stylesheet" href="https://alielmorsy.github.io/assets/css/style.css?v=559173cf7ad6a1f1f4ee2113e39c6703"><script type="application/ld+json">{"@context":"http://schema.org","@type":"Article","mainEntityOfPage":{"@type":"WebPage","@id":"https://alielmorsy.github.io/software-rasterizer-drawing-a-triangle/"},"headline":"Software Rasterizer: Drawing a Triangle","datePublished":"2025-09-09T16:31+03:00","dateModified":"2025-09-10T21:35+03:00","description":"The world of 2D graphics is built on triangles as the main primitives for drawing. In fact, even lines and complex polygons are often broken&hellip;","author":{"@type":"Person","name":"Ali Elmorsy","url":"https://alielmorsy.github.io/authors/ali-elmorsy/"},"publisher":{"@type":"Organization","name":"Ali Elmorsy"}}</script><noscript><style>img[loading] {
                    opacity: 1;
                }</style></noscript><style>.li{fill:none;stroke-linecap:round;stroke-linejoin:round;vertical-align:middle}</style><link rel="stylesheet" href="https://alielmorsy.github.io/assets/css/prism.css?v=6952794d09552e9c142036a22115f64c"></head><body class="post-template"><div class="container container--center"><header class="header"><div class="header__logo"><a class="logo" href="https://alielmorsy.github.io/">alielmorsy</a></div><nav class="navbar js-navbar"><button class="navbar__toggle js-toggle" aria-label="Menu" aria-haspopup="true" aria-expanded="false"><span class="navbar__toggle-box"><span class="navbar__toggle-inner">Menu</span></span></button><ul class="navbar__menu"><li><a href="https://alielmorsy.github.io//" target="_self">Home</a></li><li><a href="https://alielmorsy.github.io/projects-2/" target="_self">Projects</a></li><li><a href="https://alielmorsy.github.io/about-me/" target="_self">About Me</a></li></ul></nav></header><main class="content"><article class="post"><header><h1 class="post__title">Software Rasterizer: Drawing a Triangle</h1><div class="post__meta"><time datetime="2025-09-09T16:31" class="post__date">September 9, 2025 </time><span class="post__author"><a href="https://alielmorsy.github.io/authors/ali-elmorsy/" class="feed__author">Ali Elmorsy</a></span></div><div class="post__tags"><a href="https://alielmorsy.github.io/tags/barycentriccoordinates/" class="invert">BarycentricCoordinates</a> <a href="https://alielmorsy.github.io/tags/linearalgebra/" class="invert">LinearAlgebra</a> <a href="https://alielmorsy.github.io/tags/rasterization/" class="invert">Rasterization</a></div></header><div class="post__entry"><p>The world of 2D graphics is built on triangles as the main primitives for drawing. In fact, even lines and complex polygons are often broken down into triangles. This greatly simplifies the rendering process and is fundamental to how computers draw shapes efficiently.</p><div class="post__toc"><h3>Table of Contents</h3><ul><li><a href="#mcetoc_1j4qeitltda">How Vertices Are Named</a></li><li><a href="#mcetoc_1j4qeitltdb">Triangle Winding Order</a></li><li><a href="#mcetoc_1j4qeitltdc">Filling Our Triangle</a></li><li><a href="#mcetoc_1j4qeitltdd">The Edge Function Explained</a></li><li><a href="#mcetoc_1j4qeitltde">Barycentric Coordinates</a></li><li><a href="#mcetoc_1j4qeitltdf">Implementation </a></li><li><a href="#mcetoc_1j4qeitltdg">Going Further: Drawing Multiple Shapes with Indices</a><ul><li><a href="#mcetoc_1j4qeitltdh">Implementing Indexed Drawing</a></li><li><a href="#mcetoc_1j4qeitltdi">Drawing a Quad</a></li></ul></li><li><a href="#mcetoc_1j4qeitltdj">The weird edge</a></li></ul></div><p>I won’t go into what a triangle is exactly—it is simply a polygon with three points called vertices.</p><p>Something like this:</p><h2 id="mcetoc_1j4qeitltda">How Vertices Are Named</h2><p>When working with triangles, each vertex usually gets a name such as <strong>A</strong>, <strong>B</strong>, and <strong>C</strong>. This makes it easy to refer to them when performing the math to fill the triangle’s area with pixels.</p><p>For example, in a triangle defined on a 2D screen:</p><div class="info-container"><p class="msg msg--info" style="display: inline-block; padding: 10px 20px;">Vertex A = (100, 100)</p><p class="msg msg--info" style="display: inline-block; padding: 10px 20px;">Vertex B = (150, 200)</p><p class="msg msg--info" style="display: inline-block; padding: 10px 20px;">Vertex C = (200, 100)</p></div><p>Naming vertices consistently helps define the <strong>triangle’s winding order</strong>, which is critical for a rasterizer to know how to fill it correctly.</p><h2 id="mcetoc_1j4qeitltdb">Triangle Winding Order</h2><p>In 2D graphics, we do not worry about which way a triangle is facing a camera. Instead, the order in which vertices are defined matters. This is called <strong>winding order</strong> or <strong>orientation</strong>.</p><p>The order can be either clockwise or counter-clockwise:</p><ul><li><strong>Clockwise (CW)</strong>: The vertices are defined in a clockwise direction like the hands on a clock (A → B → C).</li><li><strong>Counter-Clockwise (CCW)</strong>: The vertices are defined in a counter-clockwise direction (A → C → B).</li></ul><p>This matters because our software renderer needs a consistent rule to determine which</p><p>pixels are inside the triangle. Most rasterization algorithms rely on the winding order to figure out the triangle's edges and fill the space between them.</p><p>Here is a visual example:</p><p><canvas id="winding-order-canvas" width="600" height="350"></canvas><script>const canvas = document.getElementById('winding-order-canvas');
        const ctx = canvas.getContext('2d');

        function drawArrow(ctx, fromx, fromy, tox, toy, color = 'black') {
            const headlen = 10;
            const dx = tox - fromx;
            const dy = toy - fromy;
            const angle = Math.atan2(dy, dx);
            ctx.strokeStyle = color;
            ctx.beginPath();
            ctx.moveTo(fromx, fromy);
            ctx.lineTo(tox, toy);
            ctx.stroke();
            ctx.beginPath();
            ctx.moveTo(tox, toy);
            ctx.lineTo(tox - headlen * Math.cos(angle - Math.PI / 6), toy - headlen * Math.sin(angle - Math.PI / 6));
            ctx.lineTo(tox - headlen * Math.cos(angle + Math.PI / 6), toy - headlen * Math.sin(angle + Math.PI / 6));
            ctx.lineTo(tox, toy);
            ctx.fillStyle = color;
            ctx.fill();
        }

        ctx.lineWidth = 3;
        ctx.font = 'bold 20px Courier New';
        ctx.textAlign = 'center';

        const ccw_A = { x: 75, y: 250 };
        const ccw_B = { x: 150, y: 100 };
        const ccw_C = { x: 225, y: 250 };

        ctx.fillStyle = '#333';
        ctx.fillText('Counter-Clockwise (A→C→B)', 150, 50);

        drawArrow(ctx, ccw_A.x, ccw_A.y, ccw_B.x, ccw_B.y, '#0056b3');
        drawArrow(ctx, ccw_B.x, ccw_B.y, ccw_C.x, ccw_C.y, '#0056b3');
        drawArrow(ctx, ccw_C.x, ccw_C.y, ccw_A.x, ccw_A.y, '#0056b3');

        ctx.fillText('A', ccw_A.x - 20, ccw_A.y + 10);
        ctx.fillText('B', ccw_B.x, ccw_B.y - 15);
        ctx.fillText('C', ccw_C.x + 20, ccw_C.y + 10);

        const cw_A = { x: 375, y: 250 };
        const cw_B = { x: 450, y: 100 };
        const cw_C = { x: 525, y: 250 };

        ctx.fillStyle = '#333';
        ctx.fillText('Clockwise (A→C→B)', 450, 50);

        drawArrow(ctx, cw_A.x, cw_A.y, cw_C.x, cw_C.y, '#d9534f');
        drawArrow(ctx, cw_C.x, cw_C.y, cw_B.x, cw_B.y, '#d9534f');
        drawArrow(ctx, cw_B.x, cw_B.y, cw_A.x, cw_A.y, '#d9534f');

        ctx.fillText('A', cw_A.x - 20, cw_A.y + 10);
        ctx.fillText('B', cw_B.x, cw_B.y - 15);
        ctx.fillText('C', cw_C.x + 20, cw_C.y + 10);</script></p><p>By establishing a consistent winding order, such as counter-clockwise, we can write a much simpler and more efficient filling algorithm. This is a fundamental concept that makes software rasterization fast and reliable.</p><p class="msg msg--info">This tutorial uses the counter-clockwise (CCW) convention because it is widely used.</p><h2 id="mcetoc_1j4qeitltdc">Filling Our Triangle</h2><p>To understand how the GPU fills triangles, we will implement the logic ourselves. This approach is slower but makes the learning process much clearer.</p><p>We need a method to determine whether a pixel lies inside a triangle. To do this, we use the concept of an <strong>edge</strong>. An edge is simply a line between two vertices of the triangle.</p><p>Consider an edge from vertex <strong>A</strong> to vertex <strong>C</strong> in our CCW triangle. The triangle itself always lies on one side of the edge. We can check which side a point is on using the <strong>edge function</strong>. The edge function is closely related to the concept of a signed distance function.</p><h2 id="mcetoc_1j4qeitltdd">The Edge Function Explained</h2><p>The edge function tells us whether a point <strong>P(x, y)</strong> is on the left, right, or exactly on an edge. For an edge from starting vertex <strong>V₁(x₁, y₁)</strong> to ending vertex <strong>V₂(x₂, y₂)</strong>, it is defined as:</p><p>$$E(P) = (x - x₁)(y₂ - y₁) - (y - y₁)(x₂ - x₁)$$</p><p>The result is essentially a signed area of the parallelogram formed by the vectors from <strong>V₁</strong> to <strong>V₂</strong> and from <strong>V₁</strong> to <strong>P</strong>. The sign tells us the side:</p><ul><li>If <strong>E(P) &gt; 0</strong>, point <strong>P</strong> is on the left side of the edge.</li><li>If <strong>E(P) &lt; 0</strong>, point <strong>P</strong> is on the right side of the edge.</li><li>If <strong>E(P) = 0</strong>, point <strong>P</strong> is exactly on the line.</li></ul><p>For a counter-clockwise triangle, a pixel is inside if the edge function is positive or zero for all three edges. Notice that this is equivalent to checking the sign of a signed distance function for each edge. The edge function gives a value proportional to how far a point is from the edge, with the sign indicating inside or outside.</p><h2 id="mcetoc_1j4qeitltde">Barycentric Coordinates</h2><p>We can go further and compute weights that describe how much each vertex influences a point <strong>P</strong> inside the triangle. These are called <strong>barycentric coordinates</strong>.</p><p>Take a point <strong>P</strong> inside triangle <strong>ABC</strong>. Connect <strong>P</strong> to all three vertices, forming three smaller triangles: <strong>PAB</strong>, <strong>PBC</strong>, and <strong>PCA</strong>. Each sub-triangle's area relative to the main triangle gives the barycentric coordinate of the vertex opposite that sub-triangle:</p><ul><li>Weight for <strong>A</strong> = area of triangle $PBC$ divided by total area of $ABC$</li><li>Weight for <strong>B</strong> = area of triangle $PCA$ divided by total area of $ABC$</li><li>Weight for <strong>C</strong> = area of triangle $PAB$ divided by total area of $ABC$</li></ul><p> </p><p>$$<br>\begin{aligned}<br>w_A &amp;= \frac{\text{Area of } \triangle PBC}{\text{Area of } \triangle ABC}, \\<br>w_B &amp;= \frac{\text{Area of } \triangle PCA}{\text{Area of } \triangle ABC}, \\<br>w_C &amp;= \frac{\text{Area of } \triangle PAB}{\text{Area of } \triangle ABC}.<br>\end{aligned}<br>$$</p><p>These weights always sum to one and smoothly interpolate properties across the triangle. The larger the weight for a vertex, the closer the point is to that vertex and the more influence it has.</p><p>For even a better optimizations we can do:</p><p>$$<br>w_C = 1.0 - (w_A + w_B)<br>$$</p><p>Here is a visual example with interactive sliders to move the point around and see the barycentric coordinates update:</p><p><canvas id="area-visualization-canvas" style="border: 1px solid black;" width="400" height="400"></canvas></p><div><label>X: <input id="areaPointX" max="400" min="0" type="range" value="210"></label> <label>Y: <input id="areaPointY" max="400" min="0" type="range" value="250"></label></div><p><script>(() => {
            const canvas = document.getElementById('area-visualization-canvas');
            const ctx = canvas.getContext('2d');

            const vertices = { A: { x: 80, y: 320 }, C: { x: 340, y: 300 }, B: { x: 210, y: 100 } };
            let P = { x: 210, y: 250 };

            function signedArea(p1, p2, p3) { return 0.5 * ((p1.x - p3.x)*(p2.y - p3.y) - (p2.x - p3.x)*(p1.y - p3.y)); }

            function weights(P, A, B, C) {
                const total = signedArea(A, B, C);
                const wA = signedArea(P, B, C) / total;
                const wB = signedArea(P, C, A) / total;
                const wC = 1 - wA - wB;
                return { A: wA, B: wB, C: wC };
            }

            function drawTriangle() {
                ctx.lineWidth = 3;
                ctx.strokeStyle = '#d9534f';
                ctx.beginPath();
                ctx.moveTo(vertices.A.x, vertices.A.y);
                ctx.lineTo(vertices.C.x, vertices.C.y);
                ctx.lineTo(vertices.B.x, vertices.B.y);
                ctx.closePath();
                ctx.stroke();
                ctx.fillStyle = 'black';
                ctx.font = '16px Arial';
                ctx.fillText('A', vertices.A.x - 15, vertices.A.y + 15);
                ctx.fillText('C', vertices.C.x + 5, vertices.C.y + 5);
                ctx.fillText('B', vertices.B.x - 10, vertices.B.y - 10);
            }

            function drawSubTriangles(P) {
                const colors = ['rgba(217,83,79,0.4)', 'rgba(92,184,92,0.4)', 'rgba(240,173,78,0.4)'];
                const subTriangles = [ [P, vertices.A, vertices.B], [P, vertices.B, vertices.C], [P, vertices.C, vertices.A] ];
                subTriangles.forEach((tri, i) => {
                    ctx.fillStyle = colors[i];
                    ctx.beginPath();
                    ctx.moveTo(tri[0].x, tri[0].y);
                    ctx.lineTo(tri[1].x, tri[1].y);
                    ctx.lineTo(tri[2].x, tri[2].y);
                    ctx.closePath();
                    ctx.fill();
                });
            }

            function drawPoint(P) {
                ctx.fillStyle = '#d9534f';
                ctx.beginPath();
                ctx.arc(P.x, P.y, 7, 0, Math.PI * 2);
                ctx.fill();
                const w = weights(P, vertices.A, vertices.B, vertices.C);
                ctx.fillStyle = 'black';
                ctx.font = '14px Arial';
                ctx.fillText(`A: ${w.A.toFixed(2)}`, P.x + 10, P.y - 20);
                ctx.fillText(`B: ${w.B.toFixed(2)}`, P.x + 10, P.y - 5);
                ctx.fillText(`C: ${w.C.toFixed(2)}`, P.x + 10, P.y + 10);
            }

            function render() {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                drawTriangle();
                drawSubTriangles(P);
                drawPoint(P);
            }

            document.getElementById('areaPointX').addEventListener('input', e => { P.x = parseInt(e.target.value); render(); });
            document.getElementById('areaPointY').addEventListener('input', e => { P.y = parseInt(e.target.value); render(); });

            render();
        })();</script></p><p>By moving the point, you can see how barycentric coordinates reflect its distance from each vertex. This is the principle that allows computers to fill triangles efficiently and interpolate colors, textures, or other vertex attributes across a surface. The edge function gives the sign and distance from the edge, while barycentric coordinates provide smooth weights across the triangle, linking geometry directly to rasterization and signed distance calculations.</p><p> </p><h2 id="mcetoc_1j4qeitltdf">Implementation </h2><p>Let's start by creating a simple struct called Point which contains <code>x</code>  and <code>y</code>. And let's take this even further. Let's implement it with some basic operations  +, *,-,/ </p><p>in Includes, create a file called <code>Point.h</code>:</p><pre class="language-cpp"><code>#pragma once

struct Point {
    float x, y;

    // Constructor
    Point(float x_ = 0.0f, float y_ = 0.0f) : x(x_), y(y_) {}

    // Operator overloads for point + point
    Point operator+(const Point&amp; other) const {
        return Point(x + other.x, y + other.y);
    }

    Point operator-(const Point&amp; other) const {
        return Point(x - other.x, y - other.y);
    }

    Point operator*(const Point&amp; other) const {
        return Point(x * other.x, y * other.y);
    }

    Point operator/(const Point&amp; other) const {
        return Point(x / other.x, y / other.y);
    }

    // Operator overloads for point * scalar
    Point operator*(float scalar) const {
        return Point(x * scalar, y * scalar);
    }

    Point operator/(float scalar) const {
        return Point(x / scalar, y / scalar);
    }

    // Compound assignment operators
    Point&amp; operator+=(const Point&amp; other) {
        x += other.x; y += other.y; return *this;
    }

    Point&amp; operator-=(const Point&amp; other) {
        x -= other.x; y -= other.y; return *this;
    }

    Point&amp; operator*=(const Point&amp; other) {
        x *= other.x; y *= other.y; return *this;
    }

    Point&amp; operator/=(const Point&amp; other) {
        x /= other.x; y /= other.y; return *this;
    }

    Point&amp; operator*=(float scalar) {
        x *= scalar; y *= scalar; return *this;
    }

    Point&amp; operator/=(float scalar) {
        x /= scalar; y /= scalar; return *this;
    }

};


inline Point operator*(float scalar, const Point&amp; p) {
    return Point(p.x * scalar, p.y * scalar);
}</code></pre><p> </p><p>To keep things cleaner, Let's create a header called <code>draw.h</code> and create a cpp file called <code>draw.cpp</code></p><p> <code>draw.h</code>:</p><pre class="language-cpp"><code>#pragma   once
#include &lt;cstdint&gt;
#include &lt;Point.h&gt;

void draw_triangle(uint32_t *pixels, int width, int height, Point a, Point c, Point b,uint32_t color);</code></pre><p>Let's start implementing now our <code>draw_triangle</code> function inside <code>draw.cpp</code></p><pre class="language-cpp"><code>void draw_triangle(uint32_t *pixels, int width, int height, Point a, Point c, Point b,uint32_t color) {
}</code></pre><p>Let's recall our steps in order to start drawing:</p><ol><li>Calculate the area of the triangle</li><li>Calculate the weight of each edge with the point $P$</li><li>Check if all weights bigger than or equals zero</li><li>Put a color inside this pixel</li><li>repeat for the whole buffer</li></ol><p>Something I didn't say above but the math used to calculate the area called <a href="https://en.wikipedia.org/wiki/Determinant">Determinant</a></p><p>So, Let's add a helper inside our header  to calculate the determinant</p><pre class="language-cpp"><code>inline float det2D(Point const &amp;v0, Point const &amp;v1) {
        return v0.x * v1.y - v0.y * v1.x;
    }</code></pre><p>Now, Let's write our function to draw</p><pre class="language-cpp"><code>void draw_triangle(uint32_t *pixels, int width, int height, Point a, Point c, Point b, uint32_t color) {
    // Compute triangle area using det2D
    float area = det2D(c - a, b - a);

    // Bounding box
    int minX = (int) std::floor(std::min({a.x, b.x, c.x}));
    int maxX = (int) std::ceil(std::max({a.x, b.x, c.x}));
    int minY = (int) std::floor(std::min({a.y, b.y, c.y}));
    int maxY = (int) std::ceil(std::max({a.y, b.y, c.y}));

    // Clamp to screen
    minX = std::max(minX, 0);
    maxX = std::min(maxX, width - 1);
    minY = std::max(minY, 0);
    maxY = std::min(maxY, height - 1);
    auto vd2 = b - c;
    auto vd3 = a - b;
    for (int y = minY; y &lt;= maxY; y++) {
        for (int x = minX; x &lt;= maxX; x++) {
            Point p = {(float) x , (float) y };

            // Edge functions divided by area (barycentric coordinates)
            float w0 = det2D(vd2, p - c) / area;
            float w1 = det2D(vd3, p - b) / area;
            float w2 = 1.0 - w1 - w0;

            // If point is inside triangle (all weights &gt;= 0)
            if (w0 &gt;= 0 &amp;&amp; w1 &gt;= 0 &amp;&amp; w2 &gt;= 0) {
                pixels[y * width + x] = color;
            }
        }
    }
}
</code></pre><p>What am I doing here?</p><p>First, I am doing an optimization part because in normal cases we have to loop over all pixels to determine if it's inside or outside the triangle. But we can simplify by creating a bounding box around the triangle.</p><p>I precompute the triangle area before outside the loop for performance. I also precomputed the $CA$ and $BA$ edges. </p><p> </p><p>Now, let's use it inside our main loop:</p><pre class="language-cpp"><code>while(running){
  //event handling and texture stuff...
 // Remove the loop we had and add this function call
 draw_triangle(pixels, width, height, {100, 100}, {200, 200}, {100, 200}, 0xFF0000FF); //Color is red 0xRRGGBBAA
}
</code></pre><p>If everything went smoothly we should see this in our screen</p><figure class="post__image post__image--center"><img loading="lazy" src="https://alielmorsy.github.io/media/posts/7/Screenshot-2025-09-09-212513.png" alt="" width="801" height="599" sizes="(min-width: 920px) 703px, (min-width: 700px) calc(82vw - 35px), calc(100vw - 81px)" srcset="https://alielmorsy.github.io/media/posts/7/responsive/Screenshot-2025-09-09-212513-xs.png 300w, https://alielmorsy.github.io/media/posts/7/responsive/Screenshot-2025-09-09-212513-sm.png 480w, https://alielmorsy.github.io/media/posts/7/responsive/Screenshot-2025-09-09-212513-md.png 768w, https://alielmorsy.github.io/media/posts/7/responsive/Screenshot-2025-09-09-212513-lg.png 1024w"></figure><p>Let's enhance our API a bit. So far, we can only draw one triangle at a time. What if we want to draw something more complex, like a square or any other polygon? We could call <code>draw_triangle</code> multiple times, but that's not very efficient. A better way is to use vertex and index buffers.</p><h2 id="mcetoc_1j4qeitltdg">Going Further: Drawing Multiple Shapes with Indices</h2><p>In graphics programming, we often want to draw complex objects made of many triangles. Instead of sending triangle data one by one, we can send all the geometric data to the GPU at once. This is done using two main concepts:</p><ul><li><strong>Vertex Buffer</strong>: This is just a list of all the unique vertices that make up our shape(s). Each vertex has a position (and could have other attributes like color or texture coordinates).</li><li><strong>Index Buffer</strong>: This is a list of integers. These integers are indices into the vertex buffer. They tell us how to connect the vertices to form triangles. Three consecutive indices define one triangle.</li></ul><p>Why use indices? The main reason is to save memory and performance. For example, a square is made of two triangles, but it only has four vertices. Without indices, we would have to specify 6 vertices (3 for each triangle), duplicating two of them.</p><div class="info-container"><p class="msg msg--info" style="display: inline-block; padding: 10px 20px;">With indices, we define 4 vertices and 6 indices. Without indices, we'd define 6 vertices. For complex models, this saves a lot of data!</p></div><h3 id="mcetoc_1j4qeitltdh">Implementing Indexed Drawing</h3><p>Let's update our drawing API to support indexed drawing. First, we'll add a new function to <code>draw.h</code>. We'll use <code>std::vector</code> to make it easy to pass around lists of vertices and indices.</p><p><code>draw.h</code>:</p><pre class="language-cpp"><code>#pragma once
#include &lt;cstdint&gt;
#include &lt;Point.h&gt;
#include &lt;vector&gt;

void draw_triangle(uint32_t *pixels, int width, int height, Point a, Point c, Point b, uint32_t color);

void draw_indexed(uint32_t *pixels, int width, int height, const std::vector&lt;Point&gt;&amp; vertices, const std::vector&lt;int&gt;&amp; indices, uint32_t color);
</code></pre><p>Now for the implementation in <code>draw.cpp</code>. This new function will loop through the indices, and for each triangle, it will call our existing <code>draw_triangle</code> function.</p><p><code>draw.cpp</code>:</p><pre class="language-cpp"><code>#include "draw.h"
#include &lt;algorithm&gt;
#include &lt;cmath&gt;
#include &lt;vector&gt;

// ... existing draw_triangle function ...

void draw_indexed(uint32_t *pixels, int width, int height, const std::vector&lt;Point&gt;&amp; vertices, const std::vector&lt;int&gt;&amp; indices, uint32_t color) {
    // We iterate through the indices, 3 at a time, to form triangles.
    for (size_t i = 0; i &lt; indices.size(); i += 3) {
        // Get the vertices for the current triangle from the vertex buffer
        const Point&amp; v0 = vertices[indices[i]];
        const Point&amp; v1 = vertices[indices[i + 1]];
        const Point&amp; v2 = vertices[indices[i + 2]];

        // Call our triangle drawing function.
        // Remember our function's quirky a, c, b argument order for a CCW triangle (v0, v1, v2)!
        draw_triangle(pixels, width, height, v0, v2, v1, color);
    }
}
</code></pre><p>The logic is straightforward: it takes a list of vertices and a list of indices, and for every three indices, it looks up the corresponding vertices and draws a triangle.</p><h3 id="mcetoc_1j4qeitltdi">Drawing a Quad</h3><p>Now, let's use our new function in <code>main.cpp</code> to draw a red quad. A quad can be made from two triangles. We'll define 4 vertices and 6 indices (2 triangles * 3 indices/triangle).</p><p>Here are the vertices for our quad:</p><ul><li>V0: (100, 300)</li><li>V1: (200, 300)</li><li>V2: (200, 400)</li><li>V3: (100, 400)</li></ul><p>And here's how we'll form two CCW triangles from them:</p><ul><li>Triangle 1: V0, V1, V2 (indices: 0, 1, 2)</li><li>Triangle 2: V0, V2, V3 (indices: 0, 2, 3)</li></ul><p>Let's update <code>main.cpp</code>:</p><pre class="language-cpp"><code>#include &lt;iostream&gt;
#include &lt;SDL2/SDL.h&gt;
#include &lt;vector&gt; // Make sure to include vector
#include "draw.h"

// ... clear_pixels function ...

int main(int, char**) {
    // ... SDL setup ...

    while (running) {
        // ... event handling ...

        // Lock texture to write pixels
        uint32_t *pixels;
        int pitch;
        SDL_LockTexture(texture, nullptr, reinterpret_cast&lt;void **&gt;(&amp;pixels), &amp;pitch);
        pitch /= 4;

        // Clear to white
        clear_pixels(pixels, pitch, height, 0xFFFFFFFF);

        // Define vertices and indices for a quad
        std::vector&lt;Point&gt; vertices = {
            Point(100, 300), Point(200, 300), Point(200, 400), Point(100, 400)
        };
        std::vector&lt;int&gt; indices = {
            0, 1, 2,  // First triangle (v0, v1, v2)
            0, 2, 3   // Second triangle (v0, v2, v3)
        };

        // Draw the quad using our new indexed drawing function
        draw_indexed(pixels, width, height, vertices, indices, 0xFF0000FF); // Red quad

        SDL_UnlockTexture(texture);

        // Render texture
        SDL_RenderClear(renderer);
        SDL_RenderCopy(renderer, texture, NULL, NULL);
        SDL_RenderPresent(renderer);
    }

    // ... SDL cleanup ...
    return 0;
}
</code></pre><p>And here is the result! A solid red square drawn using just one API call. This approach is much more scalable and is how modern graphics APIs work.</p><figure class="post__image post__image--center"><img loading="lazy" src="https://alielmorsy.github.io/media/posts/7/Screenshot-2025-09-09-214934.png" alt="" width="801" height="633" sizes="(min-width: 920px) 703px, (min-width: 700px) calc(82vw - 35px), calc(100vw - 81px)" srcset="https://alielmorsy.github.io/media/posts/7/responsive/Screenshot-2025-09-09-214934-xs.png 300w, https://alielmorsy.github.io/media/posts/7/responsive/Screenshot-2025-09-09-214934-sm.png 480w, https://alielmorsy.github.io/media/posts/7/responsive/Screenshot-2025-09-09-214934-md.png 768w, https://alielmorsy.github.io/media/posts/7/responsive/Screenshot-2025-09-09-214934-lg.png 1024w"></figure><p>With this new indexed drawing function, you can now easily render more complex 2D shapes by simply defining their vertices and the indices that form the triangles.</p><p> </p><h2 id="mcetoc_1j4qeitltdj">The weird edge</h2><p data-start="123" data-end="344">Something you may have noticed in our drawn objects is that there is a side that looks very sharp compared to the normal. You might think this is because there is no anti-aliasing, but actually, there is another reason.</p><p data-start="346" data-end="762">Remember when we said a point is a pixel? That's not entirely accurate because a pixel is a small rectangle. Someone might say, "So what? What's the big deal?" Here’s the big deal: when we calculate the weights to decide whether to color this pixel or not, we are actually checking only the edge of the pixel rectangle. To solve this issue, we need to center our checking point by adding $0.5$ to the point itself.</p><p data-start="346" data-end="762"> </p><p data-start="346" data-end="762">In our $X$ loop in <code>draw_triangle</code> function we need to replace our point definition with that</p><pre class="language-cpp"><code>for (int x = minX; x &lt;= maxX; x++) {
 Point p = {
                static_cast&lt;float&gt;(x) + 0.5f,
                static_cast&lt;float&gt;(y) + 0.5f
            }; // pixel center
//Calculating weights and filling the color
}</code></pre></div><footer class="wrapper post__footer"><p class="post__last-updated">This article was updated on September 10, 2025</p><div class="post__share"></div></footer><nav class="pagination"><div class="pagination__title"><span>Read other posts</span></div><div class="pagination__buttons"><a href="https://alielmorsy.github.io/software-rasterization-setup/" class="btn previous" rel="prev" aria-label="[MISSING TRANSLATION]:  Software Rasterization: Setup "><span class="btn__icon">←</span> <span class="btn__text">Software Rasterization: Setup</span> </a><a href="https://alielmorsy.github.io/software-rasterizer-coloring-and-texturing/" class="btn next" rel="next" aria-label="[MISSING TRANSLATION]:  Software Rasterizer: Coloring "><span class="btn__text">Software Rasterizer: Coloring</span> <span class="btn__icon">→</span></a></div></nav></article></main><footer class="footer"><div class="footer__inner"><div class="footer__copyright"><footer class="site-footer"><p>© 2024 Powered by Publii CMS :: <a href="https://github.com/panr/hugo-theme-terminal" target="_blank" rel="noopener">Theme</a> ported by the <a href="https://getpublii.com/customization-service/" target="_blank" rel="noopener">Publii Team</a></p></footer></div><div class="footer__social"><a href="https://www.linkedin.com/in/alielmorsy/" aria-label="LinkedIn"><svg><use xlink:href="https://alielmorsy.github.io/assets/svg/svg-map.svg#linkedin"/></svg></a></div></div></footer></div><script defer="defer" src="https://alielmorsy.github.io/assets/js/scripts.min.js?v=c2232aa7558e9517946129d2a1b8c770"></script><script defer="defer" src="https://alielmorsy.github.io/assets/js/prism.js?v=a66d6cdbe9ea6f882549bfc3bff9bde4"></script><script src="https://cdn.jsdelivr.net/npm/mathjax@4/tex-mml-chtml.js" defer="defer"></script><script>window.publiiThemeMenuConfig={mobileMenuMode:'sidebar',animationSpeed:300,submenuWidth: 'auto',doubleClickTime:500,mobileMenuExpandableSubmenus:true,relatedContainerForOverlayMenuSelector:'.top'};</script><script>var images = document.querySelectorAll('img[loading]');
        for (var i = 0; i < images.length; i++) {
            if (images[i].complete) {
                images[i].classList.add('is-loaded');
            } else {
                images[i].addEventListener('load', function () {
                    this.classList.add('is-loaded');
                }, false);
            }
        }</script><script>window.MathJax = {
  tex: {
    inlineMath: [['$', '$']],
    displayMath: [['$$', '$$']]
  },
  svg: {
    fontCache: 'global'
  }
};</script></body></html>