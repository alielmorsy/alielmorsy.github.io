<!DOCTYPE html><html lang="en-gb"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Software Rasterization: Setup - alielmorsy</title><meta name="description" content="Step-by-step tutorial on setting up a 2D software rasterizer in C++20 with SDL2. Learn project structure, rendering, and window management."><meta name="generator" content="Publii Open-Source CMS for Static Site"><link rel="canonical" href="https://alielmorsy.github.io/software-rasterization-setup/"><link rel="alternate" type="application/atom+xml" href="https://alielmorsy.github.io/feed.xml" title="alielmorsy - RSS"><link rel="alternate" type="application/json" href="https://alielmorsy.github.io/feed.json" title="alielmorsy - JSON"><meta property="og:title" content="Software Rasterization: Setup"><meta property="og:site_name" content="alielmorsy"><meta property="og:description" content="Step-by-step tutorial on setting up a 2D software rasterizer in C++20 with SDL2. Learn project structure, rendering, and window management."><meta property="og:url" content="https://alielmorsy.github.io/software-rasterization-setup/"><meta property="og:type" content="article"><link rel="preload" href="https://alielmorsy.github.io/assets/dynamic/fonts/jetbrainsmono/jetbrainsmono.woff2" as="font" type="font/woff2" crossorigin><link rel="preload" href="https://alielmorsy.github.io/assets/dynamic/fonts/jetbrainsmono/jetbrainsmono-italic.woff2" as="font" type="font/woff2" crossorigin><link rel="stylesheet" href="https://alielmorsy.github.io/assets/css/style.css?v=559173cf7ad6a1f1f4ee2113e39c6703"><script type="application/ld+json">{"@context":"http://schema.org","@type":"Article","mainEntityOfPage":{"@type":"WebPage","@id":"https://alielmorsy.github.io/software-rasterization-setup/"},"headline":"Software Rasterization: Setup","datePublished":"2025-09-08T23:18+03:00","dateModified":"2025-09-09T18:06+03:00","description":"Step-by-step tutorial on setting up a 2D software rasterizer in C++20 with SDL2. Learn project structure, rendering, and window management.","author":{"@type":"Person","name":"Ali Elmorsy","url":"https://alielmorsy.github.io/authors/ali-elmorsy/"},"publisher":{"@type":"Organization","name":"Ali Elmorsy"}}</script><noscript><style>img[loading] {
                    opacity: 1;
                }</style></noscript><style>.li{fill:none;stroke-linecap:round;stroke-linejoin:round;vertical-align:middle}</style><link rel="stylesheet" href="https://alielmorsy.github.io/assets/css/prism.css?v=6952794d09552e9c142036a22115f64c"></head><body class="post-template"><div class="container container--center"><header class="header"><div class="header__logo"><a class="logo" href="https://alielmorsy.github.io/">alielmorsy</a></div><nav class="navbar js-navbar"><button class="navbar__toggle js-toggle" aria-label="Menu" aria-haspopup="true" aria-expanded="false"><span class="navbar__toggle-box"><span class="navbar__toggle-inner">Menu</span></span></button><ul class="navbar__menu"><li><a href="https://alielmorsy.github.io//" target="_self">Home</a></li><li><a href="https://alielmorsy.github.io/projects-2/" target="_self">Projects</a></li><li><a href="https://alielmorsy.github.io/about-me/" target="_self">About Me</a></li></ul></nav></header><main class="content"><article class="post"><header><h1 class="post__title">Software Rasterization: Setup</h1><div class="post__meta"><time datetime="2025-09-08T23:18" class="post__date">September 8, 2025 </time><span class="post__author"><a href="https://alielmorsy.github.io/authors/ali-elmorsy/" class="feed__author">Ali Elmorsy</a></span></div><div class="post__tags"><a href="https://alielmorsy.github.io/tags/barycentriccoordinates/" class="invert">BarycentricCoordinates</a> <a href="https://alielmorsy.github.io/tags/linearalgebra/" class="invert">LinearAlgebra</a> <a href="https://alielmorsy.github.io/tags/rasterization/" class="invert">Rasterization</a></div></header><div class="post__entry"><p>This is the first blog post of the Project 2D Software Rasterization. In this step, we will set up our project and display a color instead of black.</p><h2>Requirements:</h2><ul><li>CPP20 (I chose C++20 because it's more common nowadays)</li><li>CMake (who uses Make in 2025?)</li><li>SDL2 (It's more common than SDL3, and the internet is full of resources in case you get stuck)</li><li>VCPkg (I am on Windows, so I need a package manager<ul><li>I have installed SDL2 already using <code>vcpkg install sdl2</code></li></ul></li></ul><h2>Step 1: Setting Up the Project</h2><p>Before writing any code, we need to organize our project and set up CMake. A clean project structure makes development easier as the project grows.</p><p>I will go with this project structure:</p><pre>├── CMakeLists.txt
├── include/
│   └── (header files go here)
├── src/
│   └── main.cpp
│   └── renderer.cpp
│   └── (other files)
└── build/ (CMake will generate build files here)</pre><p>Now let's setup cmake. I will go with this simple cmake script</p><div><pre class="language-cmake"><code>
cmake_minimum_required(VERSION 3.29)
project(rasterizer)

# Set C++ standard
set(CMAKE_CXX_STANDARD 20)
set(CMAKE_CXX_STANDARD_REQUIRED ON)

# Include directories
include_directories(${CMAKE_SOURCE_DIR}/include)

# Collect all cpp files in src/
file(GLOB_RECURSE SOURCES ${CMAKE_SOURCE_DIR}/src/*.cpp)

# Create executable from all cpp files
add_executable(rasterizer ${SOURCES})

# Find SDL2
find_package(SDL2 REQUIRED)

# Linking to SDL2
target_include_directories(rasterizer PRIVATE ${SDL2_INCLUDE_DIRS})
target_link_libraries(rasterizer PRIVATE ${SDL2_LIBRARIES})
    </code></pre><h2>Step 2: Getting a Window</h2><p>Let's write inside our <code>main</code> function</p><pre class="language-cpp"><code>constexpr int width = 800, height = 600;

SDL_Window* window = SDL_CreateWindow(
    "Software Rasterizer",
    SDL_WINDOWPOS_UNDEFINED,
    SDL_WINDOWPOS_UNDEFINED,
    width,
    height,
    SDL_WINDOW_RESIZABLE | SDL_WINDOW_SHOWN
);

if (!window) {
    std::cerr &lt;&lt; "SDL_CreateWindow Error: " &lt;&lt; SDL_GetError() &lt;&lt; std::endl;
    SDL_Quit();
    return 1;
}
</code></pre><p>We are just creating a window but our program still does nothing. To keep it alive, we need an event loop so it won’t quit immediately.</p><pre class="language-cpp"><code>bool running = true;
while (running) {
    SDL_Event event;
    while (SDL_PollEvent(&amp;event)) {
        switch (event.type) {
            case SDL_QUIT:
                running = false;
                break;
            default:
                break;
        }
    }
}</code></pre><h2>Step 3: Displaying Something</h2><p>In older SDL tutorials you would see <code>SDL_GetWindowSurface</code>. That was fine, but surfaces do not support real alpha blending on the window. The better way in 2025 is to use <code>SDL_Renderer</code> and <code>SDL_Texture</code>. They let us write our own pixels into a framebuffer and then render them to the window with full RGBA support.</p><pre class="language-cpp"><code>SDL_Renderer* renderer = SDL_CreateRenderer(window, -1, SDL_RENDERER_ACCELERATED | SDL_RENDERER_PRESENTVSYNC);
SDL_Texture* texture = SDL_CreateTexture(renderer,
                                         SDL_PIXELFORMAT_RGBA32,
                                         SDL_TEXTUREACCESS_STREAMING,
                                         width, height);

while (running) {
    SDL_Event event;
    while (SDL_PollEvent(&amp;event)) {
        if (event.type == SDL_QUIT) running = false;
    }

    // Lock texture to get direct access to pixels
    uint32_t* pixels;
    int pitch;
    SDL_LockTexture(texture, NULL, reinterpret_cast&lt;void**&gt;(&amp;pixels), &amp;pitch);
    pitch /= 4;

    // Clear to white
    for (int y = 0; y &lt; height; ++y) {
        for (int x = 0; x &lt; width; ++x) {
            pixels[y * pitch + x] = 0xFFFFFFFF;
        }
    }

    // Draw a semi transparent reddish box
    for (int y = 0; y &lt; height / 2; ++y) {
        for (int x = 0; x &lt; width / 2; ++x) {
            uint8_t r = 189, g = 55, b = 15, a = 128;
            uint8_t rb = (r * a + 255 * (255 - a)) / 255;
            uint8_t gb = (g * a + 255 * (255 - a)) / 255;
            uint8_t bb = (b * a + 255 * (255 - a)) / 255;
            pixels[y * pitch + x] = (0xFF &lt;&lt; 24) | (rb &lt;&lt; 16) | (gb &lt;&lt; 8) | bb;
        }
    }

    SDL_UnlockTexture(texture);

    // Render the texture to the window
    SDL_RenderClear(renderer);
    SDL_RenderCopy(renderer, texture, NULL, NULL);
    SDL_RenderPresent(renderer);
}
</code></pre><p>Now we are drawing directly into the texture, and SDL takes care of blending it properly when rendered. Notice the alpha value of 128 which makes the box semi transparent on top of the white background.</p><h2>Step 4: Implement clear function</h2><p>We can extract the white filling into a helper function. This makes it cleaner and prepares us for more complex rendering later.</p><pre class="language-cpp"><code>void clear_pixels(uint32_t* pixels, int width, int height, uint32_t color) {
    for (int y = 0; y &lt; height; ++y) {
        for (int x = 0; x &lt; width; ++x) {
            pixels[y * width + x] = color;
        }
    }
}
</code></pre><p>Now in the event loop we just call <code>clear_pixels</code> instead of writing the white fill manually.</p><h2>Step 5: Resizing the Window</h2><p>At this point if you resize the window, your box will not redraw correctly because the texture does not match the new size. We can fix this by catching the resize event and recreating the texture with the new width and height.</p><pre class="language-cpp"><code>else if (event.type == SDL_WINDOWEVENT &amp;&amp;
         event.window.event == SDL_WINDOWEVENT_SIZE_CHANGED) {
    width = event.window.data1;
    height = event.window.data2;

    SDL_DestroyTexture(texture);
    texture = SDL_CreateTexture(renderer,
                                SDL_PIXELFORMAT_RGBA32,
                                SDL_TEXTUREACCESS_STREAMING,
                                width, height);
}
</code></pre><p>Now every time the window size changes, we destroy the old texture and create a new one that matches. This way our program keeps drawing correctly regardless of how the user resizes the window.</p><p class="msg msg--info">This resizing step is critical in graphics programming. Without it, your frame-buffer is stuck at the old resolution and things will stretch or break when the window changes size.</p></div></div><footer class="wrapper post__footer"><p class="post__last-updated">This article was updated on September 9, 2025</p><div class="post__share"></div></footer><nav class="pagination"><div class="pagination__title"><span>Read other posts</span></div><div class="pagination__buttons"><a href="https://alielmorsy.github.io/software-rasterizer-drawing-a-triangle/" class="btn next" rel="next" aria-label="[MISSING TRANSLATION]:  Software Rasterizer: Drawing a Triangle "><span class="btn__text">Software Rasterizer: Drawing a Triangle</span> <span class="btn__icon">→</span></a></div></nav></article></main><footer class="footer"><div class="footer__inner"><div class="footer__copyright"><footer class="site-footer"><p>© 2024 Powered by Publii CMS :: <a href="https://github.com/panr/hugo-theme-terminal" target="_blank" rel="noopener">Theme</a> ported by the <a href="https://getpublii.com/customization-service/" target="_blank" rel="noopener">Publii Team</a></p></footer></div><div class="footer__social"><a href="https://www.linkedin.com/in/alielmorsy/" aria-label="LinkedIn"><svg><use xlink:href="https://alielmorsy.github.io/assets/svg/svg-map.svg#linkedin"/></svg></a></div></div></footer></div><script defer="defer" src="https://alielmorsy.github.io/assets/js/scripts.min.js?v=c2232aa7558e9517946129d2a1b8c770"></script><script defer="defer" src="https://alielmorsy.github.io/assets/js/prism.js?v=a66d6cdbe9ea6f882549bfc3bff9bde4"></script><script src="https://cdn.jsdelivr.net/npm/mathjax@4/tex-mml-chtml.js" defer="defer"></script><script>window.publiiThemeMenuConfig={mobileMenuMode:'sidebar',animationSpeed:300,submenuWidth: 'auto',doubleClickTime:500,mobileMenuExpandableSubmenus:true,relatedContainerForOverlayMenuSelector:'.top'};</script><script>var images = document.querySelectorAll('img[loading]');
        for (var i = 0; i < images.length; i++) {
            if (images[i].complete) {
                images[i].classList.add('is-loaded');
            } else {
                images[i].addEventListener('load', function () {
                    this.classList.add('is-loaded');
                }, false);
            }
        }</script><script>window.MathJax = {
  tex: {
    inlineMath: [['$', '$']],
    displayMath: [['$$', '$$']]
  },
  svg: {
    fontCache: 'global'
  }
};</script></body></html>