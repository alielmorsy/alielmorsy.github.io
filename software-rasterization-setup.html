<!DOCTYPE html><html lang="en-gb"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Software Rasterization Setup - alielmorsy</title><meta name="description" content="This is the first blog post of the Project 2D Software Rasterization. In this step, we will set up our project and display a color&hellip;"><meta name="generator" content="Publii Open-Source CMS for Static Site"><link rel="canonical" href="https://alielmorsy.github.io/software-rasterization-setup.html"><link rel="alternate" type="application/atom+xml" href="https://alielmorsy.github.io/feed.xml" title="alielmorsy - RSS"><link rel="alternate" type="application/json" href="https://alielmorsy.github.io/feed.json" title="alielmorsy - JSON"><meta property="og:title" content="Software Rasterization Setup"><meta property="og:site_name" content="alielmorsy"><meta property="og:description" content="This is the first blog post of the Project 2D Software Rasterization. In this step, we will set up our project and display a color&hellip;"><meta property="og:url" content="https://alielmorsy.github.io/software-rasterization-setup.html"><meta property="og:type" content="article"><link rel="preload" href="https://alielmorsy.github.io/assets/dynamic/fonts/jetbrainsmono/jetbrainsmono.woff2" as="font" type="font/woff2" crossorigin><link rel="preload" href="https://alielmorsy.github.io/assets/dynamic/fonts/jetbrainsmono/jetbrainsmono-italic.woff2" as="font" type="font/woff2" crossorigin><link rel="stylesheet" href="https://alielmorsy.github.io/assets/css/style.css?v=f29dbeba216e794e680bfecb374c3162"><script type="application/ld+json">{"@context":"http://schema.org","@type":"Article","mainEntityOfPage":{"@type":"WebPage","@id":"https://alielmorsy.github.io/software-rasterization-setup.html"},"headline":"Software Rasterization Setup","datePublished":"2025-09-08T23:18+03:00","dateModified":"2025-09-08T23:48+03:00","description":"This is the first blog post of the Project 2D Software Rasterization. In this step, we will set up our project and display a color&hellip;","author":{"@type":"Person","name":"Ali Elmorsy","url":"https://alielmorsy.github.io/authors/ali-elmorsy/"},"publisher":{"@type":"Organization","name":"Ali Elmorsy"}}</script><noscript><style>img[loading] {
                    opacity: 1;
                }</style></noscript><style>.li{fill:none;stroke-linecap:round;stroke-linejoin:round;vertical-align:middle}</style></head><body class="post-template"><div class="container container--center"><header class="header"><div class="header__logo"><a class="logo" href="https://alielmorsy.github.io/">alielmorsy</a></div><nav class="navbar js-navbar"><button class="navbar__toggle js-toggle" aria-label="Menu" aria-haspopup="true" aria-expanded="false"><span class="navbar__toggle-box"><span class="navbar__toggle-inner">Menu</span></span></button><ul class="navbar__menu"><li><a href="https://alielmorsy.github.io//" target="_self">Home</a></li><li><a href="https://alielmorsy.github.io/about-me.html" target="_self">About Me</a></li><li><a href="https://alielmorsy.github.io/projects-2.html" target="_self">Project</a></li></ul></nav></header><main class="content"><article class="post"><header><h1 class="post__title">Software Rasterization Setup</h1><div class="post__meta"><time datetime="2025-09-08T23:18" class="post__date">September 8, 2025 </time><span class="post__author"><a href="https://alielmorsy.github.io/authors/ali-elmorsy/" class="feed__author">Ali Elmorsy</a></span></div><div class="post__tags"><a href="https://alielmorsy.github.io/tags/barycentriccoordinates/" class="invert">BarycentricCoordinates</a> <a href="https://alielmorsy.github.io/tags/linearalgebra/" class="invert">LinearAlgebra</a> <a href="https://alielmorsy.github.io/tags/rasterization/" class="invert">Rasterization</a></div></header><div class="post__entry"><p>This is the first blog post of the Project 2D Software Rasterization. In this step, we will set up our project and display a color instead of black.</p><h2>Requirements:</h2><ul><li>CPP20 (I chose C++20 because it's more common nowadays)</li><li>CMake (who uses Make in 2025?)</li><li>SDL2 (It's more common than SDL3, and the internet is full of resources in case you get stuck)</li><li>VCPkg (I am on Windows, so I need a package manager<ul><li>I have installed SDL2 already using <code>vcpkg install sdl2</code></li></ul></li></ul><h2>Step 1: Setting Up the Project</h2><p>Before writing any code, we need to organize our project and set up CMake. A clean project structure makes development easier as the project grows.</p><p>I will go with this project structure:</p><pre>├── CMakeLists.txt
├── include/
│   └── (header files go here)
├── src/
│   └── main.cpp
│   └── renderer.cpp
│   └── (other files)
└── build/ (CMake will generate build files here)</pre><p>Now let's setup cmake. I will go with this simple cmake script</p><div><pre>cmake_minimum_required(VERSION 3.29)
project(rasterizer)

# Set C++ standard
set(CMAKE_CXX_STANDARD 20)
set(CMAKE_CXX_STANDARD_REQUIRED ON)

# Include directories
include_directories(${CMAKE_SOURCE_DIR}/include)

# Collect all cpp files in src/
file(GLOB_RECURSE SOURCES ${CMAKE_SOURCE_DIR}/src/*.cpp)

# Create executable from all cpp files
add_executable(rasterizer ${SOURCES})

# Find SDL2
find_package(SDL2 REQUIRED)

# Linking to SDL2
target_include_directories(rasterizer PRIVATE ${SDL2_INCLUDE_DIRS})
target_link_libraries(rasterizer PRIVATE ${SDL2_LIBRARIES})</pre><h2>Step 2: Getting a Window</h2><p>Let's write inside our <code>main</code>function</p><pre class="language-cpp"><code>constexpr int width = 800, height = 600;

SDL_Window* window = SDL_CreateWindow(
    "Software Rasterizer",
    SDL_WINDOWPOS_UNDEFINED,
    SDL_WINDOWPOS_UNDEFINED,
    width,
    height,
    SDL_WINDOW_RESIZABLE | SDL_WINDOW_SHOWN
);

if (!window) {
    std::cerr &lt;&lt; "SDL_CreateWindow Error: " &lt;&lt; SDL_GetError() &lt;&lt; std::endl;
    SDL_Quit();
    return 1;
}
</code></pre><p>We are just creating a window but our program still does nothing. To keep it alive, we need an event loop so it won’t quit immediately.</p><pre class="language-cpp"><code>bool running = true;
while (running) {
    SDL_Event event;
    while (SDL_PollEvent(&amp;event)) {
        switch (event.type) {
            case SDL_QUIT:
                running = false;
                break;
            default:
                break;
        }
    }
}</code></pre><h2>Step 3: Displaying Something</h2><p>Now the real work begins. We will create a framebuffer (an array of pixels), draw into it, and then copy it into the window.</p><p>SDL makes this easy: every window has a <code>SDL_Surface</code> you can get with <code>SDL_GetWindowSurface</code>. You can write directly into its <code>pixels</code> array, then call <code>SDL_UpdateWindowSurface</code> to show it on screen.</p><pre class="language-cpp"><code>SDL_Surface* screen_surface = SDL_GetWindowSurface(window);

while (running) {
    // ... handle events ...

    auto pixels = static_cast&lt;uint32_t*&gt;(screen_surface-&gt;pixels);
    int pitch = screen_surface-&gt;pitch / 4;

    for (int y = 0; y &lt; height; ++y) {
        for (int x = 0; x &lt; width; ++x) {
            pixels[y * pitch + x] = SDL_MapRGB(screen-&gt;format, x % 256, y % 256, 128);
        }
    }

    SDL_Rect rect{0, 0, width, height};
    SDL_BlitSurface(screen_surface, &amp;rect, SDL_GetWindowSurface(window), &amp;rect);
    SDL_UpdateWindowSurface(window);
}
</code></pre><p>That’s it. before the loop we iniitalize our screen surface and for each loop iteration (event loop) we loop on height and width and convert these indices to colors (coloring per pixel)</p><p class="msg msg--info">We module by <strong>255 </strong>because colors from [0..255]</p><p>Then we define a <code>SDL_Rect</code> with our width and height and we transfer our pixels to the window</p><p>If everything went correct we should see these colroful window</p><figure class="post__image post__image--center"><img loading="lazy" src="https://alielmorsy.github.io/media/posts/6/Screenshot-2025-09-08-231659.png" alt="" width="800" height="597" sizes="(min-width: 920px) 703px, (min-width: 700px) calc(82vw - 35px), calc(100vw - 81px)" srcset="https://alielmorsy.github.io/media/posts/6/responsive/Screenshot-2025-09-08-231659-xs.png 300w, https://alielmorsy.github.io/media/posts/6/responsive/Screenshot-2025-09-08-231659-sm.png 480w, https://alielmorsy.github.io/media/posts/6/responsive/Screenshot-2025-09-08-231659-md.png 768w, https://alielmorsy.github.io/media/posts/6/responsive/Screenshot-2025-09-08-231659-lg.png 1024w"></figure><p>Before we forget we need to clean this mess like surface, buffer,...etc before the program closes. </p><pre class="language-cpp"><code>while(running){
    // Event Loop...
}
//Freeing the surface frame buffer
SDL_FreeSurface(screen_surface);
//Destroying the window itself
SDL_DestroyWindow(window);
//Requesting from SDL to quit and free itself
SDL_Quit();</code></pre><p> </p><h2>Step 4: Impelment clear function</h2><p>As you saw in our event loop, we write the pixels on every iteration. That’s not actually necessary, since the pixel buffer persists between iterations. We’re doing it this way just to make it easier to understand.</p><p class="msg msg--info">Drawing on every iteration is expensive. In real program rendering like Qt or Chrome, the screen is updated only when needed, for example during animations or when something new is added. In game engines it is different because they draw every iteration. This is needed since many things change all the time such as animations, physics, and effects. </p><p> </p><p>What a clear function and why do we need it?  </p></div></div><footer class="wrapper post__footer"><p class="post__last-updated">This article was updated on September 8, 2025</p><div class="post__share"></div></footer></article></main><footer class="footer"><div class="footer__inner"><div class="footer__copyright"><footer class="site-footer"><p>© 2024 Powered by Publii CMS :: <a href="https://github.com/panr/hugo-theme-terminal" target="_blank" rel="noopener">Theme</a> ported by the <a href="https://getpublii.com/customization-service/" target="_blank" rel="noopener">Publii Team</a></p></footer></div><div class="footer__social"><a href="https://www.linkedin.com/in/alielmorsy/" aria-label="LinkedIn"><svg><use xlink:href="https://alielmorsy.github.io/assets/svg/svg-map.svg#linkedin"/></svg></a></div></div></footer></div><script defer="defer" src="https://alielmorsy.github.io/assets/js/scripts.min.js?v=c2232aa7558e9517946129d2a1b8c770"></script><script>window.publiiThemeMenuConfig={mobileMenuMode:'sidebar',animationSpeed:300,submenuWidth: 'auto',doubleClickTime:500,mobileMenuExpandableSubmenus:true,relatedContainerForOverlayMenuSelector:'.top'};</script><script>var images = document.querySelectorAll('img[loading]');
        for (var i = 0; i < images.length; i++) {
            if (images[i].complete) {
                images[i].classList.add('is-loaded');
            } else {
                images[i].addEventListener('load', function () {
                    this.classList.add('is-loaded');
                }, false);
            }
        }</script></body></html>