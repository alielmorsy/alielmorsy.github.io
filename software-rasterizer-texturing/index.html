<!DOCTYPE html><html lang="en-gb"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Software Rasterizer: Texturing - alielmorsy</title><meta name="description" content="Rendering is not only about colors. Sometimes we want to render images too. But as you might expect, that won't be as straightforward as colors&hellip;"><meta name="generator" content="Publii Open-Source CMS for Static Site"><link rel="canonical" href="https://alielmorsy.github.io/software-rasterizer-texturing/"><link rel="alternate" type="application/atom+xml" href="https://alielmorsy.github.io/feed.xml" title="alielmorsy - RSS"><link rel="alternate" type="application/json" href="https://alielmorsy.github.io/feed.json" title="alielmorsy - JSON"><meta property="og:title" content="Software Rasterizer: Texturing"><meta property="og:site_name" content="alielmorsy"><meta property="og:description" content="Rendering is not only about colors. Sometimes we want to render images too. But as you might expect, that won't be as straightforward as colors&hellip;"><meta property="og:url" content="https://alielmorsy.github.io/software-rasterizer-texturing/"><meta property="og:type" content="article"><link rel="preload" href="https://alielmorsy.github.io/assets/dynamic/fonts/jetbrainsmono/jetbrainsmono.woff2" as="font" type="font/woff2" crossorigin><link rel="preload" href="https://alielmorsy.github.io/assets/dynamic/fonts/jetbrainsmono/jetbrainsmono-italic.woff2" as="font" type="font/woff2" crossorigin><link rel="stylesheet" href="https://alielmorsy.github.io/assets/css/style.css?v=559173cf7ad6a1f1f4ee2113e39c6703"><script type="application/ld+json">{"@context":"http://schema.org","@type":"Article","mainEntityOfPage":{"@type":"WebPage","@id":"https://alielmorsy.github.io/software-rasterizer-texturing/"},"headline":"Software Rasterizer: Texturing","datePublished":"2025-09-11T23:29+03:00","dateModified":"2025-09-12T03:03+03:00","description":"Rendering is not only about colors. Sometimes we want to render images too. But as you might expect, that won't be as straightforward as colors&hellip;","author":{"@type":"Person","name":"Ali Elmorsy","url":"https://alielmorsy.github.io/authors/ali-elmorsy/"},"publisher":{"@type":"Organization","name":"Ali Elmorsy"}}</script><noscript><style>img[loading] {
                    opacity: 1;
                }</style></noscript><style>.li{fill:none;stroke-linecap:round;stroke-linejoin:round;vertical-align:middle}</style><link rel="stylesheet" href="https://alielmorsy.github.io/assets/css/prism.css?v=6952794d09552e9c142036a22115f64c"></head><body class="post-template"><div class="container container--center"><header class="header"><div class="header__logo"><a class="logo" href="https://alielmorsy.github.io/">alielmorsy</a></div><nav class="navbar js-navbar"><button class="navbar__toggle js-toggle" aria-label="Menu" aria-haspopup="true" aria-expanded="false"><span class="navbar__toggle-box"><span class="navbar__toggle-inner">Menu</span></span></button><ul class="navbar__menu"><li><a href="https://alielmorsy.github.io//" target="_self">Home</a></li><li><a href="https://alielmorsy.github.io/projects-2/" target="_self">Projects</a></li><li><a href="https://alielmorsy.github.io/about-me/" target="_self">About Me</a></li></ul></nav></header><main class="content"><article class="post"><header><h1 class="post__title">Software Rasterizer: Texturing</h1><div class="post__meta"><time datetime="2025-09-11T23:29" class="post__date">September 11, 2025 </time><span class="post__author"><a href="https://alielmorsy.github.io/authors/ali-elmorsy/" class="feed__author">Ali Elmorsy</a></span></div><div class="post__tags"><a href="https://alielmorsy.github.io/tags/rasterization/" class="invert">Rasterization</a> <a href="https://alielmorsy.github.io/tags/sampling/" class="invert">sampling</a> <a href="https://alielmorsy.github.io/tags/texel/" class="invert">texel</a></div></header><div class="post__entry"><p>Rendering is not only about colors. Sometimes we want to render images too. But as you might expect, that won't be as straightforward as colors due to many reasons:</p><ul><li>Images can easily vary in size</li><li>You may want to downscale or upscale</li></ul><p>That said, images cannot be rendered directly; we need to sample them. There are many sampling algorithms, but all of them rely on UV coordinates. I won't go into full detail—you can check a YouTube video on how UV mapping works in the world of 3D. If you've ever used software like Unity, Blender, etc., you've probably seen it.</p><p>Well, I felt a bit guilty, so let me give a quick explanation. We need a way to tell each vertex which part of the image it will hold. Obviously, we cannot use pixel positions directly because the quad we are filling might be a different size than the actual image. That's where UV coordinates come in. This is another usage of <strong>Barycentric Coordinates</strong>. We still use weights like we did in the previous post with colors, by adding another point to our Vertex struct called <code>uv</code>.</p><p><code>Vertex.h</code></p><pre class="language-cpp"><code>struct Vertex {
    Point position;
    Point uv;
    Color color;
};
</code></pre><p>That's how uv would look like for a quad (what will we use)</p><figure class="post__image post__image--center"><img loading="lazy" src="https://alielmorsy.github.io/media/posts/9/download.png" alt="" width="400" height="300" sizes="(min-width: 920px) 703px, (min-width: 700px) calc(82vw - 35px), calc(100vw - 81px)" srcset="https://alielmorsy.github.io/media/posts/9/responsive/download-xs.png 300w, https://alielmorsy.github.io/media/posts/9/responsive/download-sm.png 480w, https://alielmorsy.github.io/media/posts/9/responsive/download-md.png 768w, https://alielmorsy.github.io/media/posts/9/responsive/download-lg.png 1024w"></figure><h2>Sampling</h2><p>There are many algorithms used in texture rendering, like nearest, bilinear, and mipmaps (mostly used in GPUs). Nearest is the simplest but the least flexible. We will work with bilinear because it's easier to learn and implement.</p><p class="msg msg--info">Something that needs to be mentioned: Bilinear works by taking the average of 4 texels/pixels around the current UV coordinate, while nearest just picks the closest pixel to the calculated UV.</p><p> </p><p>Use the controls below to change source size, destination size, and toggle bilinear interpolation. The effect will update on all four canvases.</p><div class="controls"><label>Destination Width: <span id="dstWidthVal">256</span></label> <input id="dstWidth" max="512" min="32" type="range" value="256"><br><label>Destination Height: <span id="dstHeightVal">256</span></label> <input id="dstHeight" max="512" min="32" type="range" value="256"><br><label>Source Texture Size: <span id="srcSizeVal">16</span></label> <input id="srcSize" max="64" min="4" type="range" value="16"><br><label><input id="useBilinear" checked="checked" type="checkbox"> Use Bilinear</label></div><div style="font-family: system-ui, sans-serif; padding: 24px; border-radius: 12px;"><h2 style="text-align: center; margin-top: 0; margin-bottom: 24px;">Image Scaling Comparison</h2><div style="border: 1px solid #ddd; border-radius: 8px; padding: 15px; margin-bottom: 20px;"><h3 style="margin-top: 0; border-bottom: 1px solid #eee; padding-bottom: 10px; margin-bottom: 15px;">Gradient</h3><div style="display: flex; align-items: center; justify-content: space-evenly; gap: 15px; flex-wrap: wrap;"><div style="text-align: center;"><canvas id="gradientSrc" style="border: 1px solid #ccc; border-radius: 4px;" width="64" height="64"></canvas><p style="margin: 8px 0 0; font-size: 14px;">Source (64x64)</p></div><div style="font-size: 30px; font-weight: bold;">→</div><div style="text-align: center;"><canvas id="gradientDst" style="border: 1px solid #ccc; border-radius: 4px;" width="256" height="256"></canvas><p style="margin: 8px 0 0; font-size: 14px;">Scaled (256x256)</p></div></div></div><div style="border: 1px solid #ddd; border-radius: 8px; padding: 15px;"><h3 style="margin-top: 0; border-bottom: 1px solid #eee; padding-bottom: 10px; margin-bottom: 15px;">Checkerboard</h3><div style="display: flex; align-items: center; justify-content: space-evenly; gap: 15px; flex-wrap: wrap;"><div style="text-align: center;"><canvas id="checkerSrc" style="border: 1px solid #ccc; border-radius: 4px;" width="16" height="16"></canvas><p style="margin: 8px 0 0; font-size: 14px;">Source (16x16)</p></div><div style="font-size: 30px; font-weight: bold;">→</div><div style="text-align: center;"><canvas id="checkerDst" style="border: 1px solid #ccc; border-radius: 4px;" width="256" height="256"></canvas><p style="margin: 8px 0 0; font-size: 14px;">Scaled (256x256)</p></div></div></div></div><p><script>(() => {
			function BilinearDemoModule(config) {
				// config: {srcCanvas, dstCanvas, pattern}
				const srcCanvas = document.getElementById(config.srcCanvas);
				const srcCtx = srcCanvas.getContext("2d");
				const dstCanvas = document.getElementById(config.dstCanvas);
				const dstCtx = dstCanvas.getContext("2d");

				const lerp = (a, b, t) => a + (b - a) * t;

				function getPixel(imgData, x, y) {
					const idx = (y * imgData.width + x) * 4;
					const d = imgData.data;
					return [d[idx], d[idx + 1], d[idx + 2], d[idx + 3]];
				}

				function bilinearSample(imgData, u, v) {
					const w = imgData.width,
						h = imgData.height;
					u = Math.max(0, Math.min(1, u));
					v = Math.max(0, Math.min(1, v));
					const x = u * (w - 1),
						y = v * (h - 1);
					const x0 = Math.floor(x),
						y0 = Math.floor(y);
					const x1 = Math.min(x0 + 1, w - 1),
						y1 = Math.min(y0 + 1, h - 1);
					const fx = x - x0,
						fy = y - y0;
					const c00 = getPixel(imgData, x0, y0);
					const c10 = getPixel(imgData, x1, y0);
					const c01 = getPixel(imgData, x0, y1);
					const c11 = getPixel(imgData, x1, y1);
					let result = [0, 0, 0, 0];
					for (let i = 0; i < 4; i++) {
						const cx0 = lerp(c00[i], c10[i], fx);
						const cx1 = lerp(c01[i], c11[i], fx);
						result[i] = lerp(cx0, cx1, fy);
					}
					return result;
				}

				function nearestSample(imgData, u, v) {
					const w = imgData.width,
						h = imgData.height;
					const x = Math.round(u * (w - 1)),
						y = Math.round(v * (h - 1));
					return getPixel(imgData, x, y);
				}

				function createGradientPattern(size) {
					srcCanvas.width = srcCanvas.height = size;
					const imgData = srcCtx.createImageData(size, size);
					for (let y = 0; y < size; y++) {
						for (let x = 0; x < size; x++) {
							const idx = (y * size + x) * 4;
							imgData.data[idx + 0] = Math.floor(255 * x / size);
							imgData.data[idx + 1] = Math.floor(255 * y / size);
							imgData.data[idx + 2] = Math.floor(255 * (0.5 + 0.5 * Math.sin((x + y) / size * Math.PI)));
							imgData.data[idx + 3] = 255;
						}
					}
					srcCtx.putImageData(imgData, 0, 0);
				}

				function createCheckerPattern(size) {
					srcCanvas.width = srcCanvas.height = size;
					const imgData = srcCtx.createImageData(size, size);
					for (let y = 0; y < size; y++) {
						for (let x = 0; x < size; x++) {
							const idx = (y * size + x) * 4;
							const val = (x ^ y) & 1 ? 0 : 255;
							imgData.data[idx + 0] = val;
							imgData.data[idx + 1] = val;
							imgData.data[idx + 2] = val;
							imgData.data[idx + 3] = 255;
						}
					}
					srcCtx.putImageData(imgData, 0, 0);
				}

				function draw(srcSize, dstWidth, dstHeight, useBilinear) {
					dstCanvas.width = dstWidth;
					dstCanvas.height = dstHeight;
					if (config.pattern === 'gradient') createGradientPattern(srcSize);
					else createCheckerPattern(srcSize);

					const srcData = srcCtx.getImageData(0, 0, srcCanvas.width, srcCanvas.height);
					const dstData = dstCtx.createImageData(dstWidth, dstHeight);

					for (let j = 0; j < dstHeight; j++) {
						for (let i = 0; i < dstWidth; i++) {
							const u = i / (dstWidth - 1),
								v = j / (dstHeight - 1);
							const color = useBilinear ? bilinearSample(srcData, u, v) : nearestSample(srcData, u, v);
							const idx = (j * dstWidth + i) * 4;
							dstData.data[idx + 0] = color[0];
							dstData.data[idx + 1] = color[1];
							dstData.data[idx + 2] = color[2];
							dstData.data[idx + 3] = 255;
						}
					}
					dstCtx.putImageData(dstData, 0, 0);
				}

				return {
					draw
				};
			}

			// --- Shared Controls ---
			const dstWidthSlider = document.getElementById("dstWidth");
			const dstHeightSlider = document.getElementById("dstHeight");
			const srcSizeSlider = document.getElementById("srcSize");
			const useBilinearCheckbox = document.getElementById("useBilinear");

			const dstWidthVal = document.getElementById("dstWidthVal");
			const dstHeightVal = document.getElementById("dstHeightVal");
			const srcSizeVal = document.getElementById("srcSizeVal");

			// --- Initialize modules ---
			const gradientModule = BilinearDemoModule({
				srcCanvas: 'gradientSrc',
				dstCanvas: 'gradientDst',
				pattern: 'gradient'
			});
			const checkerModule = BilinearDemoModule({
				srcCanvas: 'checkerSrc',
				dstCanvas: 'checkerDst',
				pattern: 'checker'
			});

			function updateAll() {
				const srcSize = parseInt(srcSizeSlider.value);
				const dstWidth = parseInt(dstWidthSlider.value);
				const dstHeight = parseInt(dstHeightSlider.value);
				const useBilinear = useBilinearCheckbox.checked;

				dstWidthVal.textContent = dstWidth;
				dstHeightVal.textContent = dstHeight;
				srcSizeVal.textContent = srcSize;

				gradientModule.draw(srcSize, dstWidth, dstHeight, useBilinear);
				checkerModule.draw(srcSize, dstWidth, dstHeight, useBilinear);
			}

			// --- Event listeners ---
			dstWidthSlider.addEventListener("input", updateAll);
			dstHeightSlider.addEventListener("input", updateAll);
			srcSizeSlider.addEventListener("input", updateAll);
			useBilinearCheckbox.addEventListener("change", updateAll);

			// --- Initial Draw ---
			updateAll();


		})()</script></p><p>Playing with the canvases above reveals an important difference between bilinear and nearest-neighbor sampling. Notice how the checkerboard looks blurred when using bilinear.That's normal since bilinear averages the 4 closest neighbors for each pixel, sharp edges get softened. This averaging is exactly what makes gradients appear smooth, but it also means high-contrast patterns, like a checkerboard, lose their crispness when scaled.</p><p> </p><p>Now, Let's get back to code. First, we need a way to load images. Luckily, there is a single header called <a href="https://github.com/nothings/stb/blob/master/stb_image.h">stb_image</a>  that can load common image  extensions using a single API. You can download it and add it directly to our <code>include</code> folder. In order to use it, We have to do something called <code>STB_IMPLEMENTATION</code>. That header contains both implementation and the functions itself and the file is huge inling all these functions will take ages from the compiler to finish. So, we have to go to one of our CPP files and define a macro there, That macro will define all the header functions inside that CPP, so we can freely. In our <code>main.cpp</code> we add these two lines at the beginning of the file</p><pre class="language-cpp"><code>#define STB_IMAGE_IMPLEMENTATION
#include &lt;stb_image.h&gt;</code></pre><p> </p><p>Let's create a class. we will call it Sampler. We will create a header and and a cpp file for it. </p><p><code>Sampler.h</code></p><pre class="language-cpp"><code>#pragma once
#include &lt;stb_image.h&gt;
#include &lt;string_view&gt;

class Sampler {
public:
    static Sampler loadImage(std::string_view path);

    Sampler(const Sampler&amp;) = delete;

    Sampler&amp; operator=(const Sampler&amp;) = delete;

    Sampler&amp; operator=(Sampler&amp;&amp; other) noexcept {
        if (this != &amp;other) {
            if (data) stbi_image_free(data);
            width = other.width;
            height = other.height;
            channels = other.channels;
            data= other.data;

            other.data= nullptr;
            other.width = other.height = other.channels = 0;
        }
        return *this;
    }

    Sampler(Sampler&amp;&amp; other) noexcept
    : width(other.width), height(other.height), channels(other.channels), data(other.data) {
        other.data= nullptr;
    }
    
    ~Sampler() {
        if (data) {
            stbi_image_free(data);
        }
    }

private:
    size_t width, height, channels;
    uint8_t *data;
    Sampler() : width(0), height(0), channels(0), pixels(nullptr) {}


};
</code></pre><p> </p><p>It just a definition of our sampler class (which is an image + extra)</p><p class="msg--highlight msg">TBH, I was too lazy to build two different classes. I am planning to refactor most of the code in the future. So, Let's stick to that for now</p><p>Let's implement our <code>loadImage</code>function in <code>Sampler.cpp</code></p><pre class="language-cpp"><code>#include &lt;Sampler.h&gt;
#include &lt;stdexcept&gt;
#include &lt;string&gt;
#include &lt;vector&gt;


Sampler Sampler::loadImage(std::string_view path) {
    Sampler sampler;

    int w, h, c;
    sampler.data= stbi_load(path.data(), &amp;w, &amp;h, &amp;c, 0);
    if (!sampler.data) {
        throw std::runtime_error("Failed to load image: " + std::string(path));
    }

    sampler.width = static_cast&lt;size_t&gt;(w);
    sampler.height = static_cast&lt;size_t&gt;(h);
    sampler.channels = static_cast&lt;size_t&gt;(c);

    return sampler;  // Move constructor will be used here
}
</code></pre><p>Here, I’m just creating an instance of our class, then calling <code data-start="164" data-end="175">stbi_load</code>, which takes the path as a character array, along with pointers to width, height, and channels. The last parameter, number of desired channels, tells STB how many channels we want in the loaded image. Setting it to zero means we keep all the channels the file already has.</p><p>Now, Let's add a simple function called <code>at</code>which will give us the color for the current pixel. I will add it inside the header.</p><pre class="language-cpp"><code>class Sampler{
public:
//....
[[nodiscard]] Color at(size_t x, size_t y) const {
        size_t index = (y * width + x) * channels;
        const uint8_t r = pixels[index + 0]; 
        const uint8_t g = pixels[index + 1]; 
        const uint8_t b = pixels[index + 2]; 
        const uint8_t a = (channels == 4) ? pixels[index + 3] : 255;
        return {r, g, b, a};
    }
private:
//....
}</code></pre><p data-start="107" data-end="275">Unlike SDL, STB returns a flat <code data-start="138" data-end="153">unsigned char</code> buffer, where all pixel data is packed sequentially where each pixel consists of its channel values stored one after another.</p><p> </p></div><footer class="wrapper post__footer"><p class="post__last-updated">This article was updated on September 12, 2025</p><div class="post__share"></div></footer><nav class="pagination"><div class="pagination__title"><span>Read other posts</span></div><div class="pagination__buttons"><a href="https://alielmorsy.github.io/software-rasterizer-coloring-and-texturing/" class="btn previous" rel="prev" aria-label="[MISSING TRANSLATION]:  Software Rasterizer: Coloring "><span class="btn__icon">←</span> <span class="btn__text">Software Rasterizer: Coloring</span></a></div></nav></article></main><footer class="footer"><div class="footer__inner"><div class="footer__copyright"><footer class="site-footer"><p>© 2024 Powered by Publii CMS :: <a href="https://github.com/panr/hugo-theme-terminal" target="_blank" rel="noopener">Theme</a> ported by the <a href="https://getpublii.com/customization-service/" target="_blank" rel="noopener">Publii Team</a></p></footer></div><div class="footer__social"><a href="https://www.linkedin.com/in/alielmorsy/" aria-label="LinkedIn"><svg><use xlink:href="https://alielmorsy.github.io/assets/svg/svg-map.svg#linkedin"/></svg></a></div></div></footer></div><script defer="defer" src="https://alielmorsy.github.io/assets/js/scripts.min.js?v=c2232aa7558e9517946129d2a1b8c770"></script><script defer="defer" src="https://alielmorsy.github.io/assets/js/prism.js?v=a66d6cdbe9ea6f882549bfc3bff9bde4"></script><script src="https://cdn.jsdelivr.net/npm/mathjax@4/tex-mml-chtml.js" defer="defer"></script><script>window.publiiThemeMenuConfig={mobileMenuMode:'sidebar',animationSpeed:300,submenuWidth: 'auto',doubleClickTime:500,mobileMenuExpandableSubmenus:true,relatedContainerForOverlayMenuSelector:'.top'};</script><script>var images = document.querySelectorAll('img[loading]');
        for (var i = 0; i < images.length; i++) {
            if (images[i].complete) {
                images[i].classList.add('is-loaded');
            } else {
                images[i].addEventListener('load', function () {
                    this.classList.add('is-loaded');
                }, false);
            }
        }</script><script>window.MathJax = {
  tex: {
    inlineMath: [['$', '$']],
    displayMath: [['$$', '$$']]
  },
  svg: {
    fontCache: 'global'
  }
};</script></body></html>